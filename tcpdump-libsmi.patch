; From: Bill Fenner <fenner@research.att.com>
; Subject: Re: libsmi 0.2.6 && tcpdump from cvs
;
;Care to try these diffs?  I didn't see any documentation on the API
;change so I mostly just looked around for similar-looking functions.
;It at least compiles now.  (Juergen, can you look these over?)
;
;  Bill
;
Index: print-snmp.c
===================================================================
RCS file: /tcpdump/master/tcpdump/print-snmp.c,v
retrieving revision 1.42
diff -u -r1.42 print-snmp.c
--- print-snmp.c	2000/10/06 05:54:51	1.42
+++ print-snmp.c	2000/11/04 20:43:09
@@ -947,25 +947,18 @@
         SmiRange *smiRange;
 	int ok = 1;
 
-	for (smiRange = smiGetFirstRange(smiType->module, smiType->name);
+	for (smiRange = smiGetFirstRange(smiType);
 	     smiRange;
 	     smiRange = smiGetNextRange(smiRange)) {
 
 	    ok = smi_check_a_range(smiType, smiRange, elem);
-	    
-	    if (ok) {
-		smiFreeRange(smiRange);
-		break;
-	    }
 	}
 
-	if (ok && smiType->parentmodule && smiType->parentname) {
+	if (ok) {
 	    SmiType *parentType;
-	    parentType = smiGetType(smiType->parentmodule,
-				    smiType->parentname);
+	    parentType = smiGetParentType(smiType);
 	    if (parentType) {
 		ok = smi_check_range(parentType, elem);
-		smiFreeType(parentType);
 	    }
 	}
 
@@ -985,7 +978,7 @@
 		return NULL;
 	}
 	if (vflag) {
-	        fputs(smiNode->module, stdout);
+	        fputs(smiGetNodeModule(smiNode)->name, stdout);
 		fputs("::", stdout);
 	}
 	fputs(smiNode->name, stdout);
@@ -1026,17 +1019,17 @@
 	    && smiNode->access == SMI_ACCESS_NOT_ACCESSIBLE) {
 	    fputs("[noAccess]", stdout);
 	}
-
-	if (! smi_check_type(smiNode->basetype, elem->type)) {
-	    fputs("[wrongType]", stdout);
-	}
 
-	smiType = smiGetType(smiNode->typemodule, smiNode->typename);
+	smiType = smiGetNodeType(smiNode);
 	if (! smiType) {
 	    asn1_print(elem);
 	    return;
 	}
 
+	if (! smi_check_type(smiType->basetype, elem->type)) {
+	    fputs("[wrongType]", stdout);
+	}
+
 	if (! smi_check_range(smiType, elem)) {
 	    fputs("[wrongLength]", stdout);
 	}
@@ -1051,15 +1044,14 @@
 	
 	switch (elem->type) {
 	case BE_OID:
-	        if (smiNode->basetype == SMI_BASETYPE_BITS
-		    && smiNode->typemodule && smiNode->typename) {
+	        if (smiType->basetype == SMI_BASETYPE_BITS) {
 		        /* print bit labels */
 		} else {
 		        smi_decode_oid(elem, oid, &oidlen);
 			smiNode = smiGetNodeByOID(oidlen, oid);
 			if (smiNode) {
 			        if (vflag) {
-				        fputs(smiNode->module, stdout);
+					fputs(smiGetNodeModule(smiNode)->name, stdout);
 					fputs("::", stdout);
 				}
 				fputs(smiNode->name, stdout);
@@ -1075,10 +1067,8 @@
 		break;
 
 	case BE_INT:
-	        if (smiNode->basetype == SMI_BASETYPE_ENUM
-		    && smiNode->typemodule && smiNode->typename) {
-		        for (nn = smiGetFirstNamedNumber(smiNode->typemodule,
-							 smiNode->typename);
+	        if (smiType->basetype == SMI_BASETYPE_ENUM) {
+		        for (nn = smiGetFirstNamedNumber(smiType);
 			     nn;
 			     nn = smiGetNextNamedNumber(nn)) {
 			         if (nn->value.value.integer32
@@ -1096,10 +1086,6 @@
 	if (! done) {
 	        asn1_print(elem);
 	}
-
-	if (smiType) {
-	        smiFreeType(smiType);
-	}
 }
 #endif
 
@@ -1215,7 +1201,6 @@
 		        if (elem.type != BE_NULL) {
 #ifdef LIBSMI
 			        smi_print_value(smiNode, pduid, &elem);
-				smiFreeNode(smiNode);
 #else
 				asn1_print(&elem);
 #endif

